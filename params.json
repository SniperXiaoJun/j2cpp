{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"J2cpp","tagline":"java to c++ converter","body":"# j2cpp\r\n=====\r\n\r\nA Java to C++ converter, as an eclipse plug-in.\r\n\r\n***\r\n\r\nThis plugins converts Java to C++ 11. It relies on both JDT and CDT.\r\n\r\n***\r\n\r\nI created this plug-in because I had a Java code base that I needed to translate to C++ for portability reasons (iOS not to name it). The purpose of this plug-in was to handle the tedious work of porting Java syntax to C++ syntax.\r\nNote that the generated C++ code won't compile after conversion and that this converter only does the heavy lifting, you'll have of course to rework this generated code.\r\n\r\nHere is an example conversion:\r\n\r\n### BlockSituationEx.java:\r\n```java\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\nimport me.pixodro.furiousblocks.core.panel.BlockState;\r\nimport me.pixodro.furiousblocks.core.panel.BlockType;\r\nimport me.pixodro.furiousblocks.core.situations.BlockSituation;\r\nimport me.pixodro.furiousblocks.core.tools.Point;\r\n\r\npublic class BlockSituationEx extends BlockSituation {\r\n  private final Map<Integer, Integer> targetColumnCosts;\r\n  private Point origin = null;\r\n  private boolean chainReplacement = false;\r\n\r\n  public BlockSituationEx(final BlockSituation bs) {\r\n    super(bs.getId(), bs.getType(), bs.getState(), bs.getStateTick(), bs.getGarbageBlockType(), bs.getGarbageOwner(), bs.isCombo(), bs.hasJustLand(), bs.isFallingFromClearing(), bs.getPoppingIndex());\r\n    targetColumnCosts = new HashMap<Integer, Integer>();\r\n    chainReplacement = false;\r\n  }\r\n\r\n  public BlockSituationEx(final BlockSituationEx bsEx) {\r\n    super(bsEx.getId(), bsEx.getType(), bsEx.getState(), bsEx.getStateTick(), bsEx.getGarbageBlockType(), bsEx.getGarbageOwner(), bsEx.isCombo(), bsEx.hasJustLand(), bsEx.isFallingFromClearing(), bsEx.getPoppingIndex());\r\n    origin = bsEx.getOrigin();\r\n    targetColumnCosts = bsEx.targetColumnCosts;\r\n    chainReplacement = bsEx.chainReplacement;\r\n  }\r\n\r\n  private BlockSituationEx() {\r\n    super(0, BlockType.INVISIBLE, BlockState.IDLE, 0, (byte) 0, 0, false, false, false, 0);\r\n    targetColumnCosts = new HashMap<Integer, Integer>();\r\n  }\r\n\r\n  public final int getTargetColumnCost(final int targetColumn) {\r\n    // TODO: this is a bug, target cost should never be null\r\n    // return targetColumnCosts.get(targetColumn);\r\n    final Integer cost = targetColumnCosts.get(targetColumn);\r\n    return cost == null ? ComboProcessor.INFINITY : cost;\r\n  }\r\n\r\n  public final void addTargetCost(final int targetColumn, final int cost) {\r\n    targetColumnCosts.put(targetColumn, cost);\r\n  }\r\n\r\n  public final Point getOrigin() {\r\n    return origin;\r\n  }\r\n\r\n  public final void setOrigin(final Point position) {\r\n    origin = position;\r\n  }\r\n\r\n  public final void reset() {\r\n    origin = null;\r\n    targetColumnCosts.clear();\r\n    chainReplacement = false;\r\n  }\r\n\r\n  public static BlockSituationEx newInvisibleBlock() {\r\n    return new BlockSituationEx();\r\n  }\r\n\r\n  @Override\r\n  public String toString() {\r\n    return \"BlockSituationEx [origin=[\" + (origin == null ? \"null\" : (origin.x + \":\" + origin.y)) + \"], isChainReplacement = \" + isChainReplacement() + \", costs=\" + targetColumnCosts + \"]\";\r\n  }\r\n\r\n  public void setChainReplacement(final boolean comboReplacement) {\r\n    chainReplacement = comboReplacement;\r\n  }\r\n\r\n  public final boolean isChainReplacement() {\r\n    return chainReplacement;\r\n  }\r\n\r\n  public final boolean isReplacement() {\r\n    return !targetColumnCosts.isEmpty();\r\n  }\r\n}\r\n```\r\n\r\nGenerated the 2 following files:\r\n\r\n### BlockSituationEx.h:\r\n```c++\r\n#ifndef __BlockSituationEx_H_\r\n#define __BlockSituationEx_H_\r\n\r\n#include <cstdint>\r\n#include <map>\r\n#include \"BlockSituation.h\"\r\n#include \"String.h\"\r\n#include \"BlockSituationEx.h\"\r\n#include \"Point.h\"\r\n\r\nusing namespace std;\r\n\r\nclass BlockSituationEx : BlockSituation\r\n{\r\nprivate:\r\n    map<int32_t,int32_t> targetColumnCosts;\r\n    Point* origin = nullptr;\r\n    bool chainReplacement = false;\r\n    BlockSituationEx();\r\n\r\nprotected:\r\npublic:\r\n    BlockSituationEx(BlockSituation* bs);\r\n    BlockSituationEx(BlockSituationEx* bsEx);\r\n    int32_t getTargetColumnCost(int32_t targetColumn);\r\n    void addTargetCost(int32_t targetColumn, int32_t cost);\r\n    Point* getOrigin();\r\n    void setOrigin(Point* position);\r\n    void reset();\r\n    static BlockSituationEx* newInvisibleBlock();\r\n    void setChainReplacement(bool comboReplacement);\r\n    bool isChainReplacement();\r\n    bool isReplacement();\r\n};\r\n\r\n#endif //__BlockSituationEx_H_\r\n```\r\n\r\n### BlockSituationEx.cpp:\r\n```c++\r\n\r\n#include <cstdint>\r\n#include <map>\r\n#include \"BlockSituation.h\"\r\n#include \"String.h\"\r\n#include \"BlockSituationEx.h\"\r\n#include \"Point.h\"\r\n#include \"BlockSituationEx.h\"\r\n\r\nusing namespace std;\r\n\r\nBlockSituationEx::BlockSituationEx(BlockSituation* bs)\r\n{\r\n    targetColumnCosts = new map<int32_t,int32_t>();\r\n    chainReplacement = false;\r\n}\r\n\r\nBlockSituationEx::BlockSituationEx(BlockSituationEx* bsEx)\r\n{\r\n    origin = bsEx->getOrigin();\r\n    targetColumnCosts = bsEx->targetColumnCosts;\r\n    chainReplacement = bsEx->chainReplacement;\r\n}\r\n\r\nBlockSituationEx::BlockSituationEx()\r\n{\r\n    targetColumnCosts = new map<int32_t,int32_t>();\r\n}\r\n\r\nint32_t BlockSituationEx::getTargetColumnCost(int32_t targetColumn)\r\n{\r\n    int32_t cost = targetColumnCosts->get(targetColumn);\r\n    return cost == nullptr ? ComboProcessor::INFINITY : cost;\r\n}\r\n\r\nvoid BlockSituationEx::addTargetCost(int32_t targetColumn, int32_t cost)\r\n{\r\n    targetColumnCosts->put(targetColumn, cost);\r\n}\r\n\r\nPoint* BlockSituationEx::getOrigin()\r\n{\r\n    return origin;\r\n}\r\n\r\nvoid BlockSituationEx::setOrigin(Point* position)\r\n{\r\n    origin = position;\r\n}\r\n\r\nvoid BlockSituationEx::reset()\r\n{\r\n    origin = nullptr;\r\n    targetColumnCosts->clear();\r\n    chainReplacement = false;\r\n}\r\n\r\nBlockSituationEx* BlockSituationEx::newInvisibleBlock()\r\n{\r\n    return new BlockSituationEx();\r\n}\r\n\r\nvoid BlockSituationEx::setChainReplacement(bool comboReplacement)\r\n{\r\n    chainReplacement = comboReplacement;\r\n}\r\n\r\nbool BlockSituationEx::isChainReplacement()\r\n{\r\n    return chainReplacement;\r\n}\r\n\r\nbool BlockSituationEx::isReplacement()\r\n{\r\n    return !targetColumnCosts->isEmpty();\r\n}\r\n```\r\n"}